\documentclass[UTF8]{ctexart}
\usepackage{geometry, CJKutf8}
\geometry{margin=1.5cm, vmargin={0pt,1cm}}
\setlength{\topmargin}{-1cm}
\setlength{\paperheight}{29.7cm}
\setlength{\textheight}{25.3cm}

% useful packages.
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{fancyhdr}
\usepackage{layout}
\usepackage{listings}
\usepackage{float, caption}

\lstset{
    basicstyle=\ttfamily, basewidth=0.5em
}

% some common command
\newcommand{\dif}{\mathrm{d}}
\newcommand{\avg}[1]{\left\langle #1 \right\rangle}
\newcommand{\difFrac}[2]{\frac{\dif #1}{\dif #2}}
\newcommand{\pdfFrac}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\OFL}{\mathrm{OFL}}
\newcommand{\UFL}{\mathrm{UFL}}
\newcommand{\fl}{\mathrm{fl}}
\newcommand{\op}{\odot}
\newcommand{\Eabs}{E_{\mathrm{abs}}}
\newcommand{\Erel}{E_{\mathrm{rel}}}

\begin{document}

\pagestyle{fancy}
\fancyhead{}
\lhead{姚杭希, 3230102918}
\chead{数据结构与算法第四次作业}
\rhead{Oct.20th, 2024}

\section{测试程序的设计思路}

测试默认构造函数

操作：首先创建了一个空的 List<int> 实例。
结果：成功创建，无异常抛出。

测试元素添加（push_back）

操作：向列表中添加了三个整数（10, 20, 30）。
结果：元素正确添加，列表大小变为3。

测试拷贝构造函数

操作：使用已填充的列表实例化了一个新的列表。
结果：新列表与原列表元素完全相同，验证了深拷贝的正确性。

测试移动构造函数

操作：将一个列表通过移动构造函数传递给另一个新列表。
结果：原列表为空，新列表获得了原列表的所有元素。

测试赋值运算符

操作：将一个列表的内容赋值给另一个空列表。
结果：目标列表获得了与源列表相同的内容。

测试移动赋值运算符

操作：通过移动赋值将一个列表的内容赋给另一个列表。
结果：源列表变为空，目标列表获得了源列表的内容。

测试初始化列表构造函数

操作：使用初始化列表 {1, 2, 3, 4, 5} 创建了一个新列表。
结果：列表正确创建，包含了所有初始化元素。

测试访问元素（`front`, `back`）

操作：检查通过 front() 和 back() 返回的元素值。
结果：front() 返回列表的第一个元素，back() 返回最后一个元素。

测试更多元素操作（push_front, pop_front, pop_back）

操作：在列表前端添加元素，然后移除前端和后端的元素。
结果：所有操作表现如预期，列表状态正确更新。

测试插入和删除

操作：在列表中间插入一个新元素，然后删除它。
结果：元素被正确插入和删除，列表其他部分保持不变。

测试清空列表clear

操作：清空包含多个元素的列表。
结果：列表被完全清空，size() 返回0。

测试迭代器操作

操作：使用迭代器遍历列表，测试 ++ 和 -- 操作。
结果：迭代器正确遍历了列表的所有元素，正向和反向操作都符合预期。

\section{测试的结果}

After push_back: 10 20 30 

After copy constructor: 10 20 30

After move constructor: 10 20 30

After assignment operator: 10 20 30

After move assignment operator: 10 20 30

After initializer list constructor: 1 2 3 4 5

Front element: 1

Back element: 5

After push_front, pop_front, pop_back: 1 2 3 4

After insert: 1 99 2 3 4

After erase: 99 2 3 4

After clear, size: 0

Testing iterator increment: 10 20 30 1 2 3

Testing iterator decrement: 3 2 1 30 20 10

测试结果一切正常。

我用 valgrind 进行测试，发现没有发生内存泄露。

\section{（可选）bug报告}

我发现了一个 bug，触发条件如下：

\begin{enumerate}
    \item 首先……
    \item 然后……
    \item 此时发现……
\end{enumerate}

据我分析，它出现的原因是：

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
